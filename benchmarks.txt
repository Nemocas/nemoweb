<h2>Benchmarks</h2>

<p>This page shows how Nemo compares to other computer algebra software on a selection of
artificial benchmarks.</p>

<h3>Fateman benchmark</h3>

<ul>
<li>f = 1 + x + y + z + t</li>
<li>p = f^30</li>
<li>time q = p*(p + 1)</li>
</ul>

<p>This benchmark tests generic polynomial arithmetic. Note that we don't have a dedicated multivariate polynomial module in Nemo yet, so this and the next benchmark are done with nested univariate polynomial rings. Where possible we do the same thing in the other systems we time (Pari/GP is an exception).</p>
<div align="center">

<table class="benchmark">
<tr><th>SageMath 6.8</th> <th>Pari/GP 2.7.4</th>     <th>Magma V2.21-4</th>     <th>Nemo-0.3</th></tr>
<tr><td>132s</td>             <td>156s</td>               <td>233s</td>            <td>44s</td></tr>
</table>

</div>

<h3>Pearce benchmark</h3>

<ul>
<li>f = (x + y + 2z^2 + 3t^3 + 5u^5 + 1)^16</li>
<li>g = (u + t + 2z^2 + 3y^3 + 5x^5 + 1)^16</li>
<li>time q = f*g</li>
</ul>

<p>This benchmark is usually done with sparse multivariate polynomial arithmetic. We use it
here with our recursive dense polynomial arithmetic (there is no sparse polynomial representation in Nemo yet).</p>

<p>Note: this is not fair to other packages that implement sparse multivariate polynomial arithmetic,
as they could complete this benchmark faster if we used their sparse arithmetic. But that
would not be a very meaningful benchmark if the aim is to measure the relative performance
of the recursive dense polynomial arithmetic in Nemo. On the other hand, Pari/GP uses a
sparse-recursive representation (similar to recursive-dense, but with dedicated zero objects in each ring).</p>

<div align="center">

<table class="benchmark">
<tr><th>SageMath 6.8</th> <th>Pari/GP 2.7.4</th>     <th>Magma V2.21-4</th>     <th>Nemo-0.3</th></tr>
<tr><td>2900s</td>             <td>798s</td>               <td>647s</td>            <td>167s</td></tr>
</table>

</div>

<h3>Resultant benchmark</h3>

<ul>
<li>R<x> = GF(17^11)</li>
<li>S = R[y]</li>
<li>T = S/(y^3 + 3x*y + 1)</li>
<li>U = T[z]</li>
<li>f = T(3y^2 + y + x)*z^2 + T((x + 2)*y^2 + x + 1)*z + T(4x*y + 3)</li>
<li>g = T(7y^2 - y + 2x + 7)*z^2 + T(3y^2 + 4x + 1)*z + T((2x + 1)*y + 1)</li>
<li>s = f^12</li>
<li>t = (s + g)^12</li>
<li>time r = resultant(s, t)</li>
</ul>

<p>This benchmark is designed to test generics, division and computation of the resultant.</p>

<div align="center">

<table class="benchmark">
<tr><th>SageMath 6.8</th>    <th>Magma V2.21-4</th>     <th>Nemo-0.3</th></tr>
<tr><td> 179907s</td>                 <td>82s</td>            <td>0.17s</td></tr>
</table>

</div>

<h3>Bernoulli polynomials</h3>

<ul>
<li>R = QQ[x]</li>
<li>S = R[[t]]</li>
<li>u = t + O(t^1000)</li>
<li>time r = (u*exp(x*u))/(exp(u)-1))</li>
</ul>

<p>This benchmark is designed to test generic power series.</p>

<div align="center">

<table class="benchmark">
<tr><th>SageMath 6.8</th> <th>Pari/GP 2.7.4</th>      <th>Magma V2.21-4</th>     <th>Nemo-0.3</th></tr>
<tr><td>161s</td>              <td>235s</td>              <td>4223s</td>            <td>65s</td></tr>
</table>

</div>

<h3>Polynomials over number fields</h3>

<ul>
<li>R, x = CyclotomicField(20)</li>
<li>S = R[y]</li>
<li>f = (3x^7 + x^4 - 3x + 1)*y^3 + (2x^6-x^5+4x^4-x^3+x^2-1)*y +(-3x^7+2x^6-x^5+3x^3-2x^2+x)</li>
<li>time r = f^300</li>
</ul>

<p>This benchmark is designed to test dense polynomials over number fields.</p>

<div align="center">

<table class="benchmark">
<tr><th>SageMath 6.8</th> <th>Pari/GP 2.7.4</th>      <th>Magma V2.21-4</th>     <th>Nemo-0.3</th></tr>
<tr><td>6.92s</td>              <td>0.21s</td>              <td>0.70s</td>            <td>0.13s</td></tr>
</table>

</div>

<h3>Determinant over a commutative ring</h3>

<ul>
<li>n = 2003*1009</li>
<li>R = (Z/nZ)[x]</li>
<li>M is an 80x80 matrix with entries in R of random degree of at most 5 and
coefficients in the range [-100, 100] modulo n</li>
<li>time d = determinant(M)</li>
</ul>

<p>This benchmark is designed to test determinant over a generic commutative
ring. Note Pari cheats here and does divisions, which will occasionally cause
it to fail on such examples.<p>

<p>Magma exhausts the memory on the machine after some hours. Timings indicate
it uses an exponential algorithm which would take > 42369865294301626368s were
it given infinite memory.</p>

<div align="center">

<table class="benchmark">
<tr><th>SageMath 6.8</th> <th>Pari/GP 2.7.4</th>      <th>Magma V2.21-4</th>     <th>Nemo-0.3</th></tr>
<tr><td>43.5s</td>              <td>456s</td>              <td>-</td>            <td>7.5s</td></tr>
</table>

</div>

<h3>Determinant over a field</h3>

<ul>
<li>K, a = NumberField(x^3 + 3x + 1)</li>
<li>M is an 80x80 matrix with random entries in K of the form c_0 + c_1*a + c_2*a^2 with c_i in the range [-100, 100]</li>
<li>time d = determinant(M)</li>
</ul>

<p>This benchmark is designed to test determinant over a field where there is
coefficient blowup.</p>

<div align="center">

<table class="benchmark">
<tr><th>SageMath 6.8</th> <th>Pari/GP 2.7.4</th>      <th>Magma V2.21-4</th>     <th>Nemo-0.3</th></tr>
<tr><td>5893s</td>              <td>21.9s</td>              <td>5.3s</td>            <td>2.4s</td></tr>
</table>

</div>

<h3>Determinant of a matrix over a polynomial ring</h3>

<ul>
<li>M is an 40x40 matrix with random entries in ZZ[x] of the form c_0 + c_1*x + c_2*x^2 with c_i in the range [-20, 20]</li>
<li>time d = determinant(M)</li>
</ul>

<p>This benchmark is designed to test determinant over a polynomial ring over an integral domain.</p>

<div align="center">

<table class="benchmark">
<tr><th>SageMath 6.8</th> <th>Pari/GP 2.7.4</th>      <th>Magma V2.21-4</th>     <th>Nemo-0.3</th></tr>
<tr><td>6.3s</td>              <td>1.3s</td>              <td>3.2s</td>            <td>0.24s</td></tr>
</table>

</div>

<h3>Linear solving over a polynomial ring</h3>

<ul>
<li>M is an 20x20 matrix with random entries in ZZ[x][y] that are quadratic polynomials in y with coefficients of the form c_0 + c_1*x + c_2*x^2 with c_i in the range [-20, 20], and b is a 20x1 matrix over the same ring</li>
<li>time x, d = solve(M, b)</li>
</ul>

<p>The computation finds a 20x1 matrix x over ZZ[x][y] and a denominator d in ZZ[x][y] such that Ax = db.</p>

<p>This benchmark is designed to test linear solving over a generic polynomial ring.</p>

<p>Note that Sage uses a very large amount of memory and takes a long time, since it doesn't reduce the bivariate rational functions that result, at any stage. On the other hand, we are forcing Sage to work in iterated univariate polynomial rings rather than a true bivariate polynomial ring, which may explain the slowdown and memory use.</p>

<p>Magma requires the computation to be performed over the fraction field.</p>

<div align="center">

<table class="benchmark">
<tr><th>SageMath 6.8</th> <th>Pari/GP 2.7.4</th>      <th>Magma V2.21-4</th>     <th>Nemo-0.3</th></tr>
<tr><td>> 60000s</td>              <td>> 32000s</td>              <td>90s</td>            <td>7s</td></tr>
</table>

</div>


